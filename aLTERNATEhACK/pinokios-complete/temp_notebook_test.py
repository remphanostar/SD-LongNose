#!/usr/bin/env python
# coding: utf-8

# # üöÄ PinokioCloud - Complete AI App Manager for Colab\n\n**Run Pinokio apps in Google Colab with full JS/JSON script execution support**\n\nFeatures:\n- ‚úÖ Full Pinokio JS/JSON script execution\n- ‚úÖ Virtual environment isolation per app\n- ‚úÖ GPU detection and optimization\n- ‚úÖ ngrok tunneling for public access\n- ‚úÖ 284+ verified AI apps from AppData.json\n- ‚úÖ Event-driven app lifecycle management

# In[ ]:


#@title Cell 1: Clone Repository & Install Core Dependencies\nimport os\nimport sys\nimport subprocess\nfrom pathlib import Path\n\n# Clone repository if not exists\nrepo_url = 'https://github.com/remphanostar/SD-LongNose.git'\nrepo_dir = Path('/content/pinokios-complete')\n\nif not repo_dir.exists():\n    print(f'üîÑ Cloning repository...')\n    !git clone {repo_url} {repo_dir}\n    print('‚úÖ Repository cloned')\nelse:\n    print('‚úÖ Repository already exists')\n\n# Change to repo directory\nos.chdir(repo_dir)\nsys.path.insert(0, str(repo_dir))\n\n# Install core dependencies\nprint('\\nüì¶ Installing dependencies...')\n!pip install -q gitpython psutil pyngrok ipywidgets nest_asyncio\n\n# Enable nested asyncio for notebooks\nimport nest_asyncio\nnest_asyncio.apply()\n\nprint('‚úÖ Core dependencies installed')


# In[ ]:


#@title Cell 2: GPU Detection & Environment Setup\nimport platform\nimport shutil\n\ndef detect_environment():\n    """Detect GPU and environment capabilities"""\n    env_info = {\n        'platform': platform.system().lower(),\n        'python': sys.executable,\n        'gpu': None,\n        'gpu_model': None,\n        'cuda_version': None\n    }\n    \n    # Check for NVIDIA GPU\n    try:\n        result = subprocess.run(['nvidia-smi'], capture_output=True, text=True)\n        if result.returncode == 0:\n            env_info['gpu'] = 'nvidia'\n            # Extract GPU model\n            import re\n            match = re.search(r'(Tesla \\w+|A100|V100|T4|P100|K80)', result.stdout)\n            if match:\n                env_info['gpu_model'] = match.group(1)\n            \n            # Get CUDA version\n            match = re.search(r'CUDA Version: ([\\d.]+)', result.stdout)\n            if match:\n                env_info['cuda_version'] = match.group(1)\n    except FileNotFoundError:\n        pass\n    \n    return env_info\n\n# Detect environment\nenv = detect_environment()\nprint('üñ•Ô∏è  Environment Information:')\nprint(f'  Platform: {env["platform"]}')\nprint(f'  Python: {env["python"]}')\nif env['gpu']:\n    print(f'  üéÆ GPU: {env["gpu_model"]} ({env["gpu"]}) ')\n    print(f'  CUDA: {env["cuda_version"]}')\nelse:\n    print('  ‚ö†Ô∏è  No GPU detected - CPU mode only')


# In[ ]:


#@title Cell 3: Load Unified Pinokio Engine\n# Import the unified engine\nfrom pinokios.unified_engine import UnifiedPinokioEngine, PinokioContext\nimport asyncio\nimport json\n\n# Initialize engine\nengine = UnifiedPinokioEngine(base_path='/content/pinokio_apps')\nprint('‚úÖ Pinokio Engine initialized')\nprint(f'üìÇ Base path: {engine.base_path}')\nprint(f'üéÆ GPU: {engine.context.gpu or "Not detected"}')\nprint(f'üñ•Ô∏è  Platform: {engine.context.platform}')


# In[ ]:


#@title Cell 4: Load App Database\n# Load app database\napp_data_file = repo_dir / 'cleaned_pinokio_apps.json'\n\nif app_data_file.exists():\n    with open(app_data_file, 'r') as f:\n        app_database = json.load(f)\n    print(f'‚úÖ Loaded {len(app_database)} apps from database')\n    \n    # Extract unique categories\n    categories = set()\n    for app in app_database:\n        if 'category' in app:\n            categories.add(app['category'])\n    \n    print(f'\\nüìö Available Categories: {len(categories)}')\n    for cat in sorted(categories):\n        count = sum(1 for app in app_database if app.get('category') == cat)\n        print(f'  ‚Ä¢ {cat}: {count} apps')\nelse:\n    print('‚ö†Ô∏è  App database not found, creating sample data...')\n    app_database = [\n        {\n            'name': 'Stable Diffusion WebUI',\n            'repo': 'https://github.com/AUTOMATIC1111/stable-diffusion-webui',\n            'category': 'Image Generation',\n            'description': 'Popular Stable Diffusion WebUI'\n        },\n        {\n            'name': 'ComfyUI',\n            'repo': 'https://github.com/comfyanonymous/ComfyUI',\n            'category': 'Image Generation',\n            'description': 'Node-based Stable Diffusion UI'\n        }\n    ]


# In[ ]:


#@title Cell 5: ngrok Tunnel Manager\nfrom pyngrok import ngrok, conf\nimport getpass\n\nclass TunnelManager:\n    def __init__(self):\n        self.tunnels = {}\n        self.auth_token = None\n    \n    def setup_ngrok(self, auth_token=None):\n        """Setup ngrok with auth token"""\n        if not auth_token:\n            auth_token = getpass.getpass('Enter ngrok auth token (optional): ')\n        \n        if auth_token:\n            conf.get_default().auth_token = auth_token\n            self.auth_token = auth_token\n            print('‚úÖ ngrok authenticated')\n        else:\n            print('‚ö†Ô∏è  Using ngrok without auth (limited features)')\n    \n    def create_tunnel(self, port, app_name):\n        """Create ngrok tunnel for an app"""\n        try:\n            # Kill existing tunnel if any\n            if app_name in self.tunnels:\n                ngrok.disconnect(self.tunnels[app_name]['url'])\n            \n            # Create new tunnel\n            public_url = ngrok.connect(port, 'http')\n            self.tunnels[app_name] = {\n                'port': port,\n                'url': public_url,\n                'public_url': public_url.public_url\n            }\n            \n            print(f'üåê Tunnel created for {app_name}:')\n            print(f'   Local: http://localhost:{port}')\n            print(f'   Public: {public_url.public_url}')\n            \n            return public_url.public_url\n        except Exception as e:\n            print(f'‚ùå Failed to create tunnel: {e}')\n            return None\n    \n    def close_tunnel(self, app_name):\n        """Close ngrok tunnel for an app"""\n        if app_name in self.tunnels:\n            try:\n                ngrok.disconnect(self.tunnels[app_name]['url'])\n                del self.tunnels[app_name]\n                print(f'‚úÖ Tunnel closed for {app_name}')\n            except Exception as e:\n                print(f'‚ö†Ô∏è  Error closing tunnel: {e}')\n\n# Initialize tunnel manager\ntunnel_manager = TunnelManager()\nprint('üåê Tunnel manager initialized')\nprint('üí° Call tunnel_manager.setup_ngrok() to authenticate')


# In[ ]:


#@title Cell 6: Interactive App Search & Management UI\nimport ipywidgets as widgets\nfrom IPython.display import display, clear_output\n\nclass PinokioUI:\n    def __init__(self, engine, app_database, tunnel_manager):\n        self.engine = engine\n        self.apps = app_database\n        self.tunnel_manager = tunnel_manager\n        self.selected_app = None\n        \n        # Create UI components\n        self.create_widgets()\n    \n    def create_widgets(self):\n        # Search box\n        self.search_box = widgets.Text(\n            placeholder='Search apps...',\n            layout=widgets.Layout(width='100%')\n        )\n        \n        # Category filter\n        categories = ['All'] + sorted(set(app.get('category', 'Other') for app in self.apps))\n        self.category_dropdown = widgets.Dropdown(\n            options=categories,\n            value='All',\n            layout=widgets.Layout(width='200px')\n        )\n        \n        # App list\n        self.app_list = widgets.Select(\n            options=[(app['name'], i) for i, app in enumerate(self.apps[:20])],\n            rows=10,\n            layout=widgets.Layout(width='100%')\n        )\n        \n        # Action buttons\n        self.install_btn = widgets.Button(\n            description='Install',\n            button_style='primary',\n            icon='download'\n        )\n        \n        self.run_btn = widgets.Button(\n            description='Run',\n            button_style='success',\n            icon='play'\n        )\n        \n        self.stop_btn = widgets.Button(\n            description='Stop',\n            button_style='danger',\n            icon='stop'\n        )\n        \n        self.uninstall_btn = widgets.Button(\n            description='Uninstall',\n            button_style='warning',\n            icon='trash'\n        )\n        \n        # Status output\n        self.output = widgets.Output(\n            layout=widgets.Layout(\n                width='100%',\n                height='200px',\n                border='1px solid #ccc'\n            )\n        )\n        \n        # Bind events\n        self.search_box.observe(self.on_search_change, 'value')\n        self.category_dropdown.observe(self.on_category_change, 'value')\n        self.app_list.observe(self.on_app_select, 'value')\n        self.install_btn.on_click(self.install_app)\n        self.run_btn.on_click(self.run_app)\n        self.stop_btn.on_click(self.stop_app)\n        self.uninstall_btn.on_click(self.uninstall_app)\n    \n    def filter_apps(self):\n        """Filter apps based on search and category"""\n        search_term = self.search_box.value.lower()\n        category = self.category_dropdown.value\n        \n        filtered = []\n        for i, app in enumerate(self.apps):\n            # Category filter\n            if category != 'All' and app.get('category') != category:\n                continue\n            \n            # Search filter\n            if search_term:\n                if search_term not in app['name'].lower():\n                    if 'description' not in app or search_term not in app['description'].lower():\n                        continue\n            \n            filtered.append((app['name'], i))\n        \n        # Update app list\n        self.app_list.options = filtered[:50]  # Limit to 50 results\n    \n    def on_search_change(self, change):\n        self.filter_apps()\n    \n    def on_category_change(self, change):\n        self.filter_apps()\n    \n    def on_app_select(self, change):\n        if change['new'] is not None:\n            self.selected_app = self.apps[change['new']]\n            with self.output:\n                clear_output()\n                print(f"Selected: {self.selected_app['name']}")\n                if 'description' in self.selected_app:\n                    print(f"Description: {self.selected_app['description']}")\n                print(f"Category: {self.selected_app.get('category', 'Other')}")\n                \n                # Show app status\n                status = self.engine.get_app_status(self.selected_app['name'])\n                print(f"Status: {status}")\n    \n    async def install_app_async(self):\n        if not self.selected_app:\n            return\n        \n        with self.output:\n            clear_output()\n            print(f"Installing {self.selected_app['name']}...")\n            \n            success, message = await self.engine.install_app(\n                self.selected_app['name'],\n                self.selected_app['repo']\n            )\n            print(message)\n    \n    def install_app(self, btn):\n        asyncio.create_task(self.install_app_async())\n    \n    async def run_app_async(self):\n        if not self.selected_app:\n            return\n        \n        with self.output:\n            clear_output()\n            print(f"Starting {self.selected_app['name']}...")\n            \n            success, message = await self.engine.run_app(self.selected_app['name'])\n            print(message)\n            \n            # Create tunnel if app started\n            if success and 'http://' in message:\n                # Extract port from message\n                import re\n                match = re.search(r':(\\d+)', message)\n                if match:\n                    port = int(match.group(1))\n                    public_url = self.tunnel_manager.create_tunnel(port, self.selected_app['name'])\n                    if public_url:\n                        print(f"\\nüåê Public URL: {public_url}")\n    \n    def run_app(self, btn):\n        asyncio.create_task(self.run_app_async())\n    \n    def stop_app(self, btn):\n        if not self.selected_app:\n            return\n        \n        with self.output:\n            clear_output()\n            print(f"Stopping {self.selected_app['name']}...")\n            \n            # Close tunnel\n            self.tunnel_manager.close_tunnel(self.selected_app['name'])\n            \n            # Stop app\n            success, message = self.engine.stop_app(self.selected_app['name'])\n            print(message)\n    \n    async def uninstall_app_async(self):\n        if not self.selected_app:\n            return\n        \n        with self.output:\n            clear_output()\n            print(f"Uninstalling {self.selected_app['name']}...")\n            \n            success, message = await self.engine.uninstall_app(self.selected_app['name'])\n            print(message)\n    \n    def uninstall_app(self, btn):\n        asyncio.create_task(self.uninstall_app_async())\n    \n    def display(self):\n        """Display the UI"""\n        # Layout\n        search_row = widgets.HBox([\n            widgets.Label('Search:'),\n            self.search_box,\n            widgets.Label('Category:'),\n            self.category_dropdown\n        ])\n        \n        button_row = widgets.HBox([\n            self.install_btn,\n            self.run_btn,\n            self.stop_btn,\n            self.uninstall_btn\n        ])\n        \n        main_layout = widgets.VBox([\n            widgets.HTML('<h3>üöÄ PinokioCloud App Manager</h3>'),\n            search_row,\n            widgets.Label('Select an app:'),\n            self.app_list,\n            button_row,\n            widgets.Label('Output:'),\n            self.output\n        ])\n        \n        display(main_layout)\n\n# Create and display UI\nui = PinokioUI(engine, app_database, tunnel_manager)\nui.display()


# ## üéØ Quick Start Examples\n\nRun these cells to quickly test popular apps:

# In[ ]:


#@title Example: Install & Run Stable Diffusion WebUI\nasync def quick_install_sd():\n    app_name = 'stable-diffusion-webui'\n    repo_url = 'https://github.com/AUTOMATIC1111/stable-diffusion-webui'\n    \n    print('üöÄ Installing Stable Diffusion WebUI...')\n    success, message = await engine.install_app(app_name, repo_url)\n    print(message)\n    \n    if success:\n        print('\\nüé® Starting Stable Diffusion WebUI...')\n        success, message = await engine.run_app(app_name)\n        print(message)\n\n# Run installation\nawait quick_install_sd()


# In[ ]:


#@title Utility: List All Installed Apps\ninstalled = engine.list_installed_apps()\n\nif installed:\n    print('üì¶ Installed Apps:')\n    for app in installed:\n        print(f"  ‚Ä¢ {app['name']}: {app['status']}")\n        print(f"    Path: {app['path']}")\nelse:\n    print('No apps installed yet')


# In[ ]:


#@title Utility: Stop All Running Apps\nprint('üõë Stopping all running apps...')\nengine.cleanup()\nprint('‚úÖ All apps stopped')


# ## üìö Documentation\n\n### Available Methods:\n\n- `engine.install_app(name, repo_url)` - Install a Pinokio app\n- `engine.run_app(name)` - Run an installed app\n- `engine.stop_app(name)` - Stop a running app\n- `engine.uninstall_app(name)` - Uninstall an app\n- `engine.list_installed_apps()` - List all installed apps\n- `engine.get_app_status(name)` - Get app status\n\n### Tunnel Management:\n\n- `tunnel_manager.setup_ngrok(auth_token)` - Setup ngrok authentication\n- `tunnel_manager.create_tunnel(port, app_name)` - Create public tunnel\n- `tunnel_manager.close_tunnel(app_name)` - Close tunnel\n\n### Tips:\n\n1. Always authenticate ngrok for stable tunnels\n2. GPU apps will automatically use CUDA when available\n3. Each app runs in its own virtual environment\n4. Check app status before running\n5. Stop apps when done to free resources
